# M√≥dulo: Interfaz del Repartidor (Driver Interface)

**Fecha de creaci√≥n**: Enero 2025
**Versi√≥n**: 2.0
**Estado**: ‚úÖ Implementado (95% completado - Pendiente: Testing y Auth)
**Prioridad**: Alta
**√öltima actualizaci√≥n**: Enero 18, 2025

---

## üìã Tabla de Contenidos

1. [Contexto y Justificaci√≥n](#1-contexto-y-justificaci√≥n)
2. [Objetivos del M√≥dulo](#2-objetivos-del-m√≥dulo)
3. [Arquitectura y Dise√±o](#3-arquitectura-y-dise√±o)
4. [Estructura de Datos](#4-estructura-de-datos)
5. [Endpoints de API](#5-endpoints-de-api)
6. [Componentes y P√°ginas](#6-componentes-y-p√°ginas)
7. [Flujos de Usuario](#7-flujos-de-usuario)
8. [Seguridad y Autenticaci√≥n](#8-seguridad-y-autenticaci√≥n)
9. [Testing Strategy (Jest)](#9-testing-strategy-jest)
10. [Sistema de Tracking en Tiempo Real](#10-sistema-de-tracking-en-tiempo-real)
11. [Plan de Implementaci√≥n](#11-plan-de-implementaci√≥n)
12. [Asignaci√≥n de Agentes](#12-asignaci√≥n-de-agentes)

---

## 1. Contexto y Justificaci√≥n

### 1.1 Situaci√≥n Actual

El proyecto **Al Chile FB** ya cuenta con:
- ‚úÖ Sistema de pedidos completo (clientes ‚Üí admin)
- ‚úÖ Panel de control para asignar repartidores a pedidos (`/control/pedidos`)
- ‚úÖ Colecci√≥n `repartidores` en Firestore con gesti√≥n de estados
- ‚úÖ Backend endpoints para CRUD de repartidores
- ‚úÖ L√≥gica de asignaci√≥n de pedidos a repartidores

**Pero falta:**
- ‚ùå **Interfaz dedicada para que los repartidores vean sus pedidos asignados**
- ‚ùå **Sistema para que repartidores actualicen el estado de entrega**
- ‚ùå **Vista detallada con informaci√≥n de cliente y direcci√≥n**
- ‚ùå **Tracking en tiempo real del progreso de entregas**

### 1.2 Problema

Actualmente, cuando un administrador asigna un pedido a un repartidor:
1. El repartidor **NO puede ver** qu√© pedidos tiene asignados
2. El repartidor **NO puede marcar** cu√°ndo sale a entregar
3. El repartidor **NO puede confirmar** la entrega
4. El cliente **NO recibe actualizaciones** en tiempo real del estado

Esto hace que el 50% del flujo de delivery est√© incompleto, impidiendo el uso productivo del sistema.

### 1.3 Soluci√≥n Propuesta

Crear una **interfaz m√≥vil-first** para repartidores que les permita:
- üì± Ver listado de pedidos asignados
- üó∫Ô∏è Ver detalles del pedido con mapa de ubicaci√≥n
- üöÄ Marcar pedido como "En Camino"
- ‚úÖ Confirmar entrega completada
- üîî Recibir notificaciones de nuevas asignaciones

---

## 2. Objetivos del M√≥dulo

### 2.1 Funcionales

| ID | Objetivo | Descripci√≥n |
|----|----------|-------------|
| **F1** | Dashboard de Repartidor | Vista principal con pedidos asignados filtrados por estado |
| **F2** | Detalle de Pedido | Informaci√≥n completa: cliente, productos, direcci√≥n, mapa |
| **F3** | Actualizaci√≥n de Estado | Botones para cambiar estado: "Salir a Entregar" ‚Üí "Entregado" |
| **F4** | Navegaci√≥n a Direcci√≥n | Integraci√≥n con Google Maps para navegaci√≥n |
| **F5** | Historial de Entregas | Ver pedidos completados del d√≠a/semana |

### 2.2 No Funcionales

| ID | Objetivo | Descripci√≥n |
|----|----------|-------------|
| **NF1** | Responsive Mobile-First | Optimizado para celulares (repartidores usan m√≥vil) |
| **NF2** | Tiempo Real | Actualizaciones en tiempo real con Firestore subscriptions |
| **NF3** | Offline Support | Cache b√°sico para ver pedidos sin internet |
| **NF4** | Performance | Carga r√°pida (<2s) incluso con conectividad limitada |
| **NF5** | Seguridad | Solo repartidores autenticados pueden acceder |

---

## 3. Arquitectura y Dise√±o

### 3.1 Stack Tecnol√≥gico

```
Frontend:
  - Next.js 15 (App Router)
  - React 18 + TypeScript
  - Tailwind CSS + shadcn/ui
  - Google Maps React API (para mapas)
  - Firebase Client SDK (Auth + Firestore real-time)

Backend:
  - Express.js (puerto 8080)
  - Firebase Admin SDK
  - Endpoints RESTful

Database:
  - Firestore (real-time subscriptions)
  - Colecciones: repartidores, orders

Autenticaci√≥n:
  - Firebase Auth con custom claim: 'repartidor'
```

### 3.2 Diagrama de Arquitectura

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    REPARTIDOR (MOBILE)                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  /repartidor/dashboard  (Protected Route)           ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ    - Lista de pedidos asignados                      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ    - Estados: Asignado / En Camino / Entregado      ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                          ‚Üì                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  /repartidor/pedidos/[id]  (Detalle)                ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ    - Informaci√≥n del cliente                         ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ    - Lista de productos                              ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ    - Mapa con direcci√≥n                              ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ    - Botones: "En Camino" / "Entregado"             ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì Firebase Auth + Firestore
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    BACKEND (Express.js)                     ‚îÇ
‚îÇ  GET    /api/repartidores/me                                ‚îÇ
‚îÇ  GET    /api/repartidores/me/pedidos                        ‚îÇ
‚îÇ  PUT    /api/pedidos/:id/marcar-en-camino                   ‚îÇ
‚îÇ  PUT    /api/pedidos/:id/marcar-entregado                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FIRESTORE COLLECTIONS                    ‚îÇ
‚îÇ  - repartidores (name, phone, status, userId)              ‚îÇ
‚îÇ  - orders (userId, items, driverId, status, address)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 4. Estructura de Datos

### 4.1 Colecci√≥n: `repartidores`

**Campos existentes** (ya implementados):
```typescript
interface Repartidor {
  id: string;                    // Firestore document ID
  name: string;                  // Nombre completo
  phone: string;                 // Tel√©fono de contacto
  status: 'disponible' | 'ocupado';  // Estado actual
  assignedOrderCount: number;    // Cantidad de pedidos activos
  createdAt: Timestamp;
  updatedAt: Timestamp;
  deleted: boolean;              // Soft delete
}
```

**Campos a AGREGAR**:
```typescript
interface RepartidorExtended extends Repartidor {
  userId?: string;               // Firebase Auth UID (para autenticaci√≥n)
  email?: string;                // Email para login
  photoURL?: string;             // Foto de perfil (opcional)
  vehicleType?: 'moto' | 'bici' | 'auto' | 'pie';  // Tipo de veh√≠culo
}
```

### 4.2 Colecci√≥n: `orders`

**Campos relevantes para repartidor** (ya existentes):
```typescript
interface Order {
  id: string;
  userId: string;                // Cliente que hizo el pedido
  driverId?: string;             // ID del repartidor asignado ‚Üê CLAVE
  status: 'Pedido Realizado' | 'Preparando' | 'En Reparto' | 'Entregado';
  shippingAddress: {
    street: string;
    city: string;
    state: string;
    postalCode: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
    phone: string;
    name: string;
  };
  items: Array<{
    id: string;
    name: string;
    quantity: number;
    price: number;
  }>;
  totalVerified: number;
  paymentMethod: 'cash' | 'card' | 'transfer';
  statusHistory: Array<{
    status: string;
    timestamp: Timestamp;
    updatedBy?: string;
  }>;
  createdAt: Timestamp;
}
```

### 4.3 Custom Claims de Firebase

**Nuevo rol necesario:**
```typescript
interface CustomClaims {
  super_admin?: boolean;   // Existente
  admin?: boolean;         // Existente
  repartidor?: boolean;    // ‚Üê NUEVO (para repartidores)
}
```

**Nota de seguridad (Raptoure):**
- Los custom claims deben asignarse SOLO desde el backend con Firebase Admin SDK
- NUNCA permitir que el frontend modifique claims
- Usar `authMiddleware` para verificar el claim `repartidor` en todos los endpoints

---

## 5. Endpoints de API

### 5.1 Endpoints a CREAR

#### **GET /api/repartidores/me**
Obtiene la informaci√≥n del repartidor autenticado (basado en Firebase Auth UID).

**Autenticaci√≥n:** Bearer Token (Firebase ID Token)
**Autorizaci√≥n:** Custom claim `repartidor: true`

**Request:**
```bash
GET /api/repartidores/me
Authorization: Bearer <firebase-id-token>
```

**Response 200:**
```json
{
  "id": "repartidor123",
  "name": "Juan P√©rez",
  "phone": "555-1234",
  "status": "disponible",
  "assignedOrderCount": 2,
  "email": "juan@alchile.com",
  "vehicleType": "moto"
}
```

**Response 401:** Usuario no autenticado
**Response 403:** Usuario no tiene claim `repartidor`
**Response 404:** Repartidor no encontrado en Firestore

---

#### **GET /api/repartidores/me/pedidos**
Obtiene los pedidos asignados al repartidor autenticado.

**Query Parameters:**
- `status` (opcional): Filtrar por estado (`En Reparto`, `Entregado`, etc.)
- `date` (opcional): Filtrar por fecha (`today`, `week`, `all`)

**Request:**
```bash
GET /api/repartidores/me/pedidos?status=En Reparto
Authorization: Bearer <firebase-id-token>
```

**Response 200:**
```json
{
  "pedidos": [
    {
      "id": "order123",
      "status": "En Reparto",
      "customerName": "Mar√≠a Gonz√°lez",
      "customerPhone": "555-9876",
      "shippingAddress": {
        "street": "Calle Principal 123",
        "city": "Ciudad",
        "coordinates": { "lat": 19.4326, "lng": -99.1332 }
      },
      "items": [
        { "name": "Alb√≥ndigas Cl√°sicas", "quantity": 2, "price": 150 }
      ],
      "total": 300,
      "paymentMethod": "cash",
      "createdAt": "2025-01-18T10:30:00Z"
    }
  ],
  "count": 1
}
```

---

#### **PUT /api/pedidos/:orderId/marcar-en-camino**
Marca un pedido como "En Reparto" y registra la hora de salida.

**Autenticaci√≥n:** Bearer Token
**Autorizaci√≥n:** Custom claim `repartidor: true`
**Validaci√≥n:** Solo el repartidor asignado puede marcar su pedido

**Request:**
```bash
PUT /api/pedidos/order123/marcar-en-camino
Authorization: Bearer <firebase-id-token>
Content-Type: application/json

{
  "currentLocation": {
    "lat": 19.4326,
    "lng": -99.1332
  }
}
```

**Response 200:**
```json
{
  "success": true,
  "order": {
    "id": "order123",
    "status": "En Reparto",
    "statusHistory": [
      { "status": "En Reparto", "timestamp": "2025-01-18T11:00:00Z", "updatedBy": "repartidor123" }
    ]
  }
}
```

**Response 403:** El pedido no est√° asignado a este repartidor
**Response 404:** Pedido no encontrado
**Response 400:** Estado actual no permite esta transici√≥n

---

#### **PUT /api/pedidos/:orderId/marcar-entregado**
Marca un pedido como "Entregado" y libera al repartidor.

**Request:**
```bash
PUT /api/pedidos/order123/marcar-entregado
Authorization: Bearer <firebase-id-token>
Content-Type: application/json

{
  "deliveryNotes": "Entregado en mano. Cliente satisfecho.",
  "signature": "data:image/png;base64,..." // Opcional: firma digital
}
```

**Response 200:**
```json
{
  "success": true,
  "order": {
    "id": "order123",
    "status": "Entregado",
    "deliveredAt": "2025-01-18T11:45:00Z"
  },
  "driverStatusUpdated": true
}
```

**Efectos secundarios:**
- Actualiza `orders.status` ‚Üí "Entregado"
- Decrementa `repartidores.assignedOrderCount`
- Si `assignedOrderCount` === 0, cambia `repartidores.status` ‚Üí "disponible"
- Registra en `statusHistory`

---

### 5.2 Endpoints Existentes (Sin cambios)

Ya implementados en el backend:
- `GET /api/control/drivers` - Listar repartidores (admin)
- `POST /api/control/drivers` - Crear repartidor (admin)
- `PUT /api/pedidos/control/:orderId/asignar-repartidor` - Asignar repartidor (admin)

---

## 6. Componentes y P√°ginas

### 6.1 Estructura de Archivos

```
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ repartidor/                    # Nueva secci√≥n
‚îÇ       ‚îú‚îÄ‚îÄ layout.tsx                 # Layout con navbar mobile
‚îÇ       ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard (redirect a /dashboard)
‚îÇ       ‚îú‚îÄ‚îÄ dashboard/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Lista de pedidos asignados
‚îÇ       ‚îú‚îÄ‚îÄ pedidos/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ [id]/
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Detalle de pedido
‚îÇ       ‚îî‚îÄ‚îÄ historial/
‚îÇ           ‚îî‚îÄ‚îÄ page.tsx               # Pedidos completados
‚îÇ
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ repartidor/                    # Componentes espec√≠ficos
‚îÇ       ‚îú‚îÄ‚îÄ OrderCard.tsx              # Card de pedido en lista
‚îÇ       ‚îú‚îÄ‚îÄ OrderDetailMap.tsx         # Mapa con ubicaci√≥n del cliente
‚îÇ       ‚îú‚îÄ‚îÄ DeliveryActions.tsx        # Botones de acci√≥n (En Camino/Entregado)
‚îÇ       ‚îú‚îÄ‚îÄ CustomerInfo.tsx           # Info del cliente
‚îÇ       ‚îú‚îÄ‚îÄ OrderItems.tsx             # Lista de productos
‚îÇ       ‚îî‚îÄ‚îÄ DriverStats.tsx            # Estad√≠sticas del repartidor
‚îÇ
‚îî‚îÄ‚îÄ hooks/
    ‚îî‚îÄ‚îÄ use-driver-orders.ts           # Hook para obtener pedidos del repartidor
```

---

### 6.2 Componentes Detallados

#### **6.2.1 DriverDashboard** (`/repartidor/dashboard/page.tsx`)

**Funcionalidad:**
- Muestra lista de pedidos asignados al repartidor
- Filtros por estado: Todos / Asignado / En Camino / Entregados
- Pull-to-refresh en m√≥vil
- Indicador de pedidos pendientes vs completados

**Mockup visual:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üöó Mis Pedidos          [üë§ Perfil]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  üìä Hoy: 3 entregas | 2 pendientes    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  [Todos] [Pendientes] [En Camino]     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ üü¢ En Camino                     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Mar√≠a Gonz√°lez                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Calle Principal 123              ‚îÇ ‚îÇ
‚îÇ  ‚îÇ $300 ‚Ä¢ Efectivo ‚Ä¢ 2 productos    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ [Ver Detalles ‚Üí]                 ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ üîµ Asignado                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Juan P√©rez                       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Av. Reforma 456                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ $450 ‚Ä¢ Tarjeta ‚Ä¢ 3 productos     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ [Ver Detalles ‚Üí]                 ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Componente principal:**
```tsx
// src/app/repartidor/dashboard/page.tsx
'use client';

import { useDriverOrders } from '@/hooks/use-driver-orders';
import { OrderCard } from '@/components/repartidor/OrderCard';
import { DriverStats } from '@/components/repartidor/DriverStats';
import { withAuth } from '@/components/auth/withAuth';
import { useState } from 'react';

function DriverDashboard() {
  const { orders, loading, error, refetch } = useDriverOrders();
  const [filter, setFilter] = useState<'all' | 'pending' | 'in-progress'>('pending');

  const filteredOrders = orders.filter(order => {
    if (filter === 'pending') return order.status === 'Preparando';
    if (filter === 'in-progress') return order.status === 'En Reparto';
    return true;
  });

  if (loading) return <div className="p-4">Cargando pedidos...</div>;
  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;

  return (
    <div className="min-h-screen bg-gray-50 pb-20">
      <header className="bg-primary text-white p-4">
        <h1 className="text-xl font-bold">üöó Mis Pedidos</h1>
      </header>

      <DriverStats orders={orders} />

      <div className="p-4 flex gap-2 mb-4">
        <button
          onClick={() => setFilter('all')}
          className={`px-4 py-2 rounded ${filter === 'all' ? 'bg-primary text-white' : 'bg-white'}`}
        >
          Todos
        </button>
        <button
          onClick={() => setFilter('pending')}
          className={`px-4 py-2 rounded ${filter === 'pending' ? 'bg-primary text-white' : 'bg-white'}`}
        >
          Pendientes
        </button>
        <button
          onClick={() => setFilter('in-progress')}
          className={`px-4 py-2 rounded ${filter === 'in-progress' ? 'bg-primary text-white' : 'bg-white'}`}
        >
          En Camino
        </button>
      </div>

      <div className="p-4 space-y-4">
        {filteredOrders.length === 0 ? (
          <div className="text-center text-gray-500 py-8">
            No tienes pedidos {filter !== 'all' && `en estado "${filter}"`}
          </div>
        ) : (
          filteredOrders.map(order => (
            <OrderCard key={order.id} order={order} />
          ))
        )}
      </div>
    </div>
  );
}

export default withAuth(DriverDashboard, 'repartidor');
```

---

#### **6.2.2 OrderDetailPage** (`/repartidor/pedidos/[id]/page.tsx`)

**Funcionalidad:**
- Informaci√≥n completa del pedido
- Mapa interactivo con ubicaci√≥n del cliente
- Botones de acci√≥n seg√∫n estado:
  - Si est√° "Asignado" ‚Üí Bot√≥n "Salir a Entregar"
  - Si est√° "En Camino" ‚Üí Bot√≥n "Marcar como Entregado"
- Bot√≥n para abrir Google Maps / Waze con navegaci√≥n
- Informaci√≥n de contacto del cliente (llamar con un tap)

**Mockup visual:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  [‚Üê] Pedido #1234                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  üü¢ Estado: En Camino                  ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  üë§ Cliente                            ‚îÇ
‚îÇ  Mar√≠a Gonz√°lez                        ‚îÇ
‚îÇ  üìû 555-9876  [Llamar]                 ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  üìç Direcci√≥n                          ‚îÇ
‚îÇ  Calle Principal 123, Col. Centro     ‚îÇ
‚îÇ  Ciudad, Estado, CP 12345              ‚îÇ
‚îÇ  [Abrir en Maps üó∫Ô∏è]                   ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ     [MAPA INTERACTIVO]           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ   üìç ‚Üê Ubicaci√≥n del cliente     ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  üõçÔ∏è Productos                          ‚îÇ
‚îÇ  ‚Ä¢ Alb√≥ndigas Cl√°sicas x2 - $150     ‚îÇ
‚îÇ  ‚Ä¢ Bebida x1 - $50                   ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  üí∞ Total: $300                        ‚îÇ
‚îÇ  üíµ Pago: Efectivo                     ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  [üöÄ Marcar como Entregado]            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Componente principal:**
```tsx
// src/app/repartidor/pedidos/[id]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import { useDoc } from '@/hooks/use-doc';
import { OrderDetailMap } from '@/components/repartidor/OrderDetailMap';
import { DeliveryActions } from '@/components/repartidor/DeliveryActions';
import { CustomerInfo } from '@/components/repartidor/CustomerInfo';
import { OrderItems } from '@/components/repartidor/OrderItems';
import { withAuth } from '@/components/auth/withAuth';

function OrderDetailPage() {
  const params = useParams();
  const router = useRouter();
  const orderId = params.id as string;

  const { data: order, loading } = useDoc(`orders/${orderId}`);

  if (loading) return <div className="p-4">Cargando...</div>;
  if (!order) return <div className="p-4">Pedido no encontrado</div>;

  return (
    <div className="min-h-screen bg-white">
      <header className="bg-primary text-white p-4 flex items-center gap-4">
        <button onClick={() => router.back()} className="text-2xl">‚Üê</button>
        <h1 className="text-lg font-bold">Pedido #{order.id.slice(0, 8)}</h1>
      </header>

      <div className="p-4 space-y-6">
        <div className="text-center">
          <span className={`inline-block px-4 py-2 rounded-full text-white ${
            order.status === 'En Reparto' ? 'bg-green-600' : 'bg-blue-600'
          }`}>
            {order.status}
          </span>
        </div>

        <CustomerInfo customer={order.shippingAddress} />
        <OrderDetailMap address={order.shippingAddress} />
        <OrderItems items={order.items} total={order.totalVerified} paymentMethod={order.paymentMethod} />
        <DeliveryActions order={order} />
      </div>
    </div>
  );
}

export default withAuth(OrderDetailPage, 'repartidor');
```

---

#### **6.2.3 DeliveryActions** (Componente de botones)

**L√≥gica de estados:**
```tsx
// src/components/repartidor/DeliveryActions.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { useUser } from '@/firebase/provider';

interface DeliveryActionsProps {
  order: any;
}

export function DeliveryActions({ order }: DeliveryActionsProps) {
  const [loading, setLoading] = useState(false);
  const { toast } = useToast();
  const { user } = useUser();
  const router = useRouter();

  const getCurrentPosition = (): Promise<GeolocationPosition> => {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation not supported'));
      }
      navigator.geolocation.getCurrentPosition(resolve, reject);
    });
  };

  const handleStartDelivery = async () => {
    setLoading(true);
    try {
      let currentLocation = null;
      try {
        const position = await getCurrentPosition();
        currentLocation = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
        };
      } catch (geoError) {
        console.warn('No se pudo obtener ubicaci√≥n:', geoError);
      }

      const token = await user?.getIdToken();
      const response = await fetch(`/api/pedidos/${order.id}/marcar-en-camino`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({ currentLocation }),
      });

      if (response.ok) {
        toast({ title: '‚úÖ Pedido marcado como En Camino' });
      } else {
        const error = await response.json();
        toast({ title: error.message || 'Error al actualizar', variant: 'destructive' });
      }
    } catch (error) {
      toast({ title: 'Error al actualizar', variant: 'destructive' });
    } finally {
      setLoading(false);
    }
  };

  const handleCompleteDelivery = async () => {
    setLoading(true);
    try {
      const token = await user?.getIdToken();
      const response = await fetch(`/api/pedidos/${order.id}/marcar-entregado`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          deliveryNotes: 'Entregado correctamente',
        }),
      });

      if (response.ok) {
        toast({ title: 'üéâ Pedido entregado con √©xito' });
        router.push('/repartidor/dashboard');
      } else {
        const error = await response.json();
        toast({ title: error.message || 'Error al completar', variant: 'destructive' });
      }
    } catch (error) {
      toast({ title: 'Error al completar', variant: 'destructive' });
    } finally {
      setLoading(false);
    }
  };

  // L√≥gica de botones seg√∫n estado
  if (order.status === 'Preparando') {
    return (
      <Button
        onClick={handleStartDelivery}
        disabled={loading}
        className="w-full bg-blue-600 hover:bg-blue-700"
        size="lg"
      >
        üöÄ Salir a Entregar
      </Button>
    );
  }

  if (order.status === 'En Reparto') {
    return (
      <Button
        onClick={handleCompleteDelivery}
        disabled={loading}
        className="w-full bg-green-600 hover:bg-green-700"
        size="lg"
      >
        ‚úÖ Marcar como Entregado
      </Button>
    );
  }

  return (
    <div className="text-center text-gray-500 p-4">
      Pedido ya entregado
    </div>
  );
}
```

---

### 6.3 Hooks Personalizados

#### **use-driver-orders.ts**

```tsx
// src/hooks/use-driver-orders.ts
import { useState, useEffect } from 'react';
import { useUser } from '@/firebase/provider';
import { collection, query, where, onSnapshot, orderBy } from 'firebase/firestore';
import { db } from '@/firebase/config';

export function useDriverOrders() {
  const { user } = useUser();
  const [orders, setOrders] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!user) {
      setLoading(false);
      return;
    }

    const fetchDriverIdAndSubscribe = async () => {
      try {
        const token = await user.getIdToken();
        const response = await fetch('/api/repartidores/me', {
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        });

        if (!response.ok) {
          throw new Error('No se pudo obtener informaci√≥n del repartidor');
        }

        const driver = await response.json();

        // Suscribirse a los pedidos en tiempo real
        const ordersRef = collection(db, 'orders');
        const q = query(
          ordersRef,
          where('driverId', '==', driver.id),
          where('status', 'in', ['Preparando', 'En Reparto']),
          orderBy('createdAt', 'desc')
        );

        const unsubscribe = onSnapshot(q, (snapshot) => {
          const ordersData = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data(),
          }));

          setOrders(ordersData);
          setLoading(false);
        }, (err) => {
          setError(err.message);
          setLoading(false);
        });

        return unsubscribe;
      } catch (err: any) {
        setError(err.message);
        setLoading(false);
      }
    };

    const unsubscribePromise = fetchDriverIdAndSubscribe();

    return () => {
      unsubscribePromise.then(unsub => unsub?.());
    };
  }, [user]);

  const refetch = async () => {
    setLoading(true);
    setError(null);
  };

  return { orders, loading, error, refetch };
}
```

---

## 7. Flujos de Usuario

### 7.1 Flujo Principal: Entrega de Pedido

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FLUJO DE ENTREGA                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. ADMIN asigna pedido a repartidor
   ‚îî‚îÄ> Firestore: orders.driverId = "repartidor123"
   ‚îî‚îÄ> Firestore: repartidores.assignedOrderCount++
   ‚îî‚îÄ> Estado pedido: "Preparando"

2. REPARTIDOR ve notificaci√≥n de nuevo pedido
   ‚îî‚îÄ> Dashboard actualizado en tiempo real (Firestore subscription)
   ‚îî‚îÄ> Aparece card con el pedido en "Pendientes"

3. REPARTIDOR abre detalle del pedido
   ‚îî‚îÄ> GET /api/repartidores/me/pedidos
   ‚îî‚îÄ> Ve informaci√≥n completa: cliente, productos, direcci√≥n, mapa

4. REPARTIDOR sale a entregar
   ‚îî‚îÄ> Tap en bot√≥n "üöÄ Salir a Entregar"
   ‚îî‚îÄ> PUT /api/pedidos/:id/marcar-en-camino
   ‚îî‚îÄ> Firestore: orders.status = "En Reparto"
   ‚îî‚îÄ> Firestore: orders.statusHistory[] += nuevo registro
   ‚îî‚îÄ> Cliente ve actualizaci√≥n en su dashboard

5. REPARTIDOR llega y entrega el pedido
   ‚îî‚îÄ> Tap en bot√≥n "‚úÖ Marcar como Entregado"
   ‚îî‚îÄ> PUT /api/pedidos/:id/marcar-entregado
   ‚îî‚îÄ> Firestore: orders.status = "Entregado"
   ‚îî‚îÄ> Firestore: repartidores.assignedOrderCount--
   ‚îî‚îÄ> Si assignedOrderCount === 0:
       ‚îî‚îÄ> Firestore: repartidores.status = "disponible"
   ‚îî‚îÄ> Cliente recibe confirmaci√≥n de entrega

6. REPARTIDOR regresa al dashboard
   ‚îî‚îÄ> Pedido movido a "Completados"
   ‚îî‚îÄ> Listo para siguiente entrega
```

---

### 7.2 Flujo Secundario: Login de Repartidor

```
1. Repartidor accede a /repartidor/dashboard
   ‚îî‚îÄ> withAuth detecta que no hay sesi√≥n
   ‚îî‚îÄ> Redirige a /ingresar?redirect=/repartidor/dashboard

2. Repartidor ingresa email y contrase√±a
   ‚îî‚îÄ> Firebase Auth verifica credenciales
   ‚îî‚îÄ> Backend verifica custom claim 'repartidor'

3. Si claim es v√°lido:
   ‚îî‚îÄ> Permite acceso a /repartidor/dashboard
   ‚îî‚îÄ> Carga pedidos asignados

4. Si NO tiene claim 'repartidor':
   ‚îî‚îÄ> Muestra error: "No tienes permisos de repartidor"
   ‚îî‚îÄ> Redirige a /
```

---

## 8. Seguridad y Autenticaci√≥n

**Responsable:** üõ°Ô∏è **Raptoure** (Agente de Seguridad)

### 8.1 Principios de Seguridad

1. **Autenticaci√≥n Robusta**
   - ‚úÖ Todos los endpoints requieren Firebase ID Token v√°lido
   - ‚úÖ Verificaci√≥n en backend con Firebase Admin SDK
   - ‚úÖ Custom claim `repartidor: true` obligatorio

2. **Autorizaci√≥n Granular**
   - ‚úÖ Repartidor solo puede ver SUS pedidos asignados
   - ‚úÖ Validaci√≥n: `order.driverId === req.user.driverId`
   - ‚úÖ No puede modificar pedidos de otros repartidores

3. **Firestore Security Rules**

```javascript
// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Repartidores: Solo admins pueden crear/editar
    match /repartidores/{repartidorId} {
      allow read: if request.auth != null &&
                     (request.auth.token.admin == true ||
                      request.auth.token.repartidor == true);
      allow write: if request.auth.token.admin == true;
    }

    // Pedidos: Repartidor puede leer solo los suyos
    match /orders/{orderId} {
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.userId ||  // Cliente
        request.auth.token.admin == true ||          // Admin
        (request.auth.token.repartidor == true &&
         resource.data.driverId == request.auth.uid) // Repartidor asignado
      );

      // Solo admin puede asignar repartidor
      allow update: if request.auth.token.admin == true;

      // Repartidor solo puede actualizar status (validado en backend)
      allow update: if request.auth.token.repartidor == true &&
                       resource.data.driverId == request.auth.uid &&
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['status', 'statusHistory', 'deliveredAt']);
    }
  }
}
```

### 8.2 Validaciones en Backend

**Endpoint: PUT /api/pedidos/:id/marcar-en-camino**

```javascript
// backend/app.js
app.put('/api/pedidos/:orderId/marcar-en-camino', authMiddleware, async (req, res) => {
  try {
    const { orderId } = req.params;
    const { currentLocation } = req.body;

    // 1. Verificar que el usuario tiene claim 'repartidor'
    if (!req.user.repartidor) {
      return res.status(403).json({
        message: 'Solo repartidores pueden usar este endpoint'
      });
    }

    // 2. Obtener el pedido
    const orderRef = db.collection('orders').doc(orderId);
    const orderDoc = await orderRef.get();

    if (!orderDoc.exists) {
      return res.status(404).json({ message: 'Pedido no encontrado' });
    }

    const order = orderDoc.data();

    // 3. Verificar que el pedido est√° asignado a ESTE repartidor
    const repartidorRef = await db.collection('repartidores')
      .where('userId', '==', req.user.uid)
      .where('deleted', '==', false)
      .limit(1)
      .get();

    if (repartidorRef.empty) {
      return res.status(404).json({ message: 'Repartidor no encontrado' });
    }

    const repartidorId = repartidorRef.docs[0].id;

    if (order.driverId !== repartidorId) {
      return res.status(403).json({
        message: 'Este pedido no est√° asignado a ti'
      });
    }

    // 4. Verificar que el estado actual permite la transici√≥n
    if (order.status !== 'Preparando') {
      return res.status(400).json({
        message: `No se puede marcar en camino desde estado: ${order.status}`
      });
    }

    // 5. Actualizar el pedido
    await orderRef.update({
      status: 'En Reparto',
      statusHistory: admin.firestore.FieldValue.arrayUnion({
        status: 'En Reparto',
        timestamp: admin.firestore.Timestamp.now(),
        updatedBy: repartidorId,
        location: currentLocation || null,
      }),
    });

    res.status(200).json({
      success: true,
      message: 'Pedido marcado como En Reparto'
    });

  } catch (error) {
    console.error('Error al marcar pedido en camino:', error);
    res.status(500).json({ message: 'Error interno del servidor' });
  }
});
```

### 8.3 Checklist de Seguridad (Raptoure)

- [ ] Custom claim `repartidor` implementado
- [ ] Script para asignar claim desde backend
- [ ] authMiddleware verifica claim en todos los endpoints
- [ ] Firestore rules limitan acceso a pedidos por driverId
- [ ] Validaci√≥n backend: repartidor solo modifica SUS pedidos
- [ ] No se expone informaci√≥n de otros repartidores
- [ ] Logs de auditor√≠a en statusHistory (qui√©n cambi√≥ qu√©)
- [ ] Rate limiting en endpoints cr√≠ticos (opcional)
- [ ] HTTPS obligatorio en producci√≥n

---

## 9. Testing Strategy (Jest)

**Responsable:** üß™ **Vanguard** (Agente de Pruebas)

### 9.1 Tests de Frontend (Jest + React Testing Library)

#### **DeliveryActions.test.tsx**
```typescript
// src/components/repartidor/DeliveryActions.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { DeliveryActions } from './DeliveryActions';
import { useUser } from '@/firebase/provider';
import { useToast } from '@/hooks/use-toast';
import { useRouter } from 'next/navigation';

jest.mock('@/firebase/provider');
jest.mock('@/hooks/use-toast');
jest.mock('next/navigation');

describe('DeliveryActions', () => {
  const mockUseUser = useUser as jest.MockedFunction<typeof useUser>;
  const mockUseToast = useToast as jest.MockedFunction<typeof useToast>;
  const mockUseRouter = useRouter as jest.MockedFunction<typeof useRouter>;
  const mockToast = jest.fn();
  const mockPush = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    mockUseUser.mockReturnValue({
      user: { getIdToken: jest.fn().mockResolvedValue('test-token') },
      isUserLoading: false,
    });
    mockUseToast.mockReturnValue({ toast: mockToast });
    mockUseRouter.mockReturnValue({ push: mockPush } as any);
    global.fetch = jest.fn();
  });

  it('should show "Salir a Entregar" button when status is Preparando', () => {
    const order = { id: '123', status: 'Preparando', driverId: 'driver1' };
    render(<DeliveryActions order={order} />);
    expect(screen.getByText(/Salir a Entregar/i)).toBeInTheDocument();
  });

  it('should show "Marcar como Entregado" when status is En Reparto', () => {
    const order = { id: '123', status: 'En Reparto', driverId: 'driver1' };
    render(<DeliveryActions order={order} />);
    expect(screen.getByText(/Marcar como Entregado/i)).toBeInTheDocument();
  });

  it('should call API when clicking "Salir a Entregar"', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({ ok: true });
    const order = { id: '123', status: 'Preparando', driverId: 'driver1' };
    render(<DeliveryActions order={order} />);

    fireEvent.click(screen.getByText(/Salir a Entregar/i));

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/pedidos/123/marcar-en-camino',
        expect.objectContaining({ method: 'PUT' })
      );
    });
  });

  it('should show toast on successful delivery completion', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({ ok: true });
    const order = { id: '123', status: 'En Reparto', driverId: 'driver1' };
    render(<DeliveryActions order={order} />);

    fireEvent.click(screen.getByText(/Marcar como Entregado/i));

    await waitFor(() => {
      expect(mockToast).toHaveBeenCalledWith({
        title: expect.stringContaining('√©xito')
      });
    });
  });

  it('should show error toast on API failure', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: false,
      json: async () => ({ message: 'Error de prueba' })
    });
    const order = { id: '123', status: 'Preparando', driverId: 'driver1' };
    render(<DeliveryActions order={order} />);

    fireEvent.click(screen.getByText(/Salir a Entregar/i));

    await waitFor(() => {
      expect(mockToast).toHaveBeenCalledWith({
        title: 'Error de prueba',
        variant: 'destructive'
      });
    });
  });
});
```

---

### 9.2 Tests de Backend (Jest + Supertest)

#### **repartidor-endpoints.test.js**
```javascript
// backend/repartidor-endpoints.test.js
const request = require('supertest');
const app = require('./app');
const admin = require('firebase-admin');

// Mocks de Firebase Admin (usar el patr√≥n documentado en AGENTS.md)
jest.mock('firebase-admin', () => {
  // ... (mock completo seg√∫n plantilla de Vanguard)
});

describe('GET /api/repartidores/me', () => {
  it('should return 403 for non-repartidor user', async () => {
    const res = await request(app)
      .get('/api/repartidores/me')
      .set('Authorization', 'Bearer test-regular-user-token');

    expect(res.statusCode).toBe(403);
    expect(res.body.message).toContain('repartidor');
  });

  it('should return 404 if repartidor document not found', async () => {
    admin.__mockGetEmpty.mockReturnValueOnce(true);

    const res = await request(app)
      .get('/api/repartidores/me')
      .set('Authorization', 'Bearer test-repartidor-token');

    expect(res.statusCode).toBe(404);
  });

  it('should return repartidor data for valid token', async () => {
    admin.__mockGetEmpty.mockReturnValueOnce(false);
    admin.__mockDocs.mockReturnValueOnce([{
      id: 'repartidor123',
      data: () => ({
        name: 'Juan P√©rez',
        phone: '555-1234',
        status: 'disponible',
        assignedOrderCount: 2
      })
    }]);

    const res = await request(app)
      .get('/api/repartidores/me')
      .set('Authorization', 'Bearer test-repartidor-token');

    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('name', 'Juan P√©rez');
    expect(res.body).toHaveProperty('status', 'disponible');
  });
});

describe('GET /api/repartidores/me/pedidos', () => {
  it('should return only assigned orders for repartidor', async () => {
    const mockOrders = [
      { id: 'order1', driverId: 'repartidor123', status: 'Preparando' },
      { id: 'order2', driverId: 'repartidor123', status: 'En Reparto' }
    ];

    admin.__mockGetEmpty.mockReturnValueOnce(false);
    admin.__mockDocs.mockReturnValue(mockOrders.map(o => ({
      id: o.id,
      data: () => o
    })));

    const res = await request(app)
      .get('/api/repartidores/me/pedidos')
      .set('Authorization', 'Bearer test-repartidor-token');

    expect(res.statusCode).toBe(200);
    expect(res.body.pedidos).toHaveLength(2);
    expect(res.body.pedidos.every(p => p.driverId === 'repartidor123')).toBe(true);
  });
});

describe('PUT /api/pedidos/:id/marcar-en-camino', () => {
  it('should return 403 if order not assigned to this driver', async () => {
    admin.__mockGetExists.mockReturnValueOnce(true);
    admin.__mockGetData.mockReturnValueOnce({ driverId: 'other-driver' });

    const res = await request(app)
      .put('/api/pedidos/order123/marcar-en-camino')
      .set('Authorization', 'Bearer test-repartidor-token')
      .send({});

    expect(res.statusCode).toBe(403);
    expect(res.body.message).toContain('no est√° asignado');
  });

  it('should update order status to En Reparto', async () => {
    admin.__mockGetExists.mockReturnValueOnce(true);
    admin.__mockGetData.mockReturnValueOnce({
      driverId: 'repartidor123',
      status: 'Preparando'
    });

    const res = await request(app)
      .put('/api/pedidos/order123/marcar-en-camino')
      .set('Authorization', 'Bearer test-repartidor-token')
      .send({ currentLocation: { lat: 19.4326, lng: -99.1332 } });

    expect(res.statusCode).toBe(200);
    expect(res.body.success).toBe(true);
    expect(admin.__mockUpdate).toHaveBeenCalledWith(
      expect.objectContaining({ status: 'En Reparto' })
    );
  });

  it('should return 400 if status transition is invalid', async () => {
    admin.__mockGetExists.mockReturnValueOnce(true);
    admin.__mockGetData.mockReturnValueOnce({
      driverId: 'repartidor123',
      status: 'Entregado' // Ya entregado
    });

    const res = await request(app)
      .put('/api/pedidos/order123/marcar-en-camino')
      .set('Authorization', 'Bearer test-repartidor-token')
      .send({});

    expect(res.statusCode).toBe(400);
  });
});

describe('PUT /api/pedidos/:id/marcar-entregado', () => {
  it('should update order and driver status', async () => {
    admin.__mockGetExists.mockReturnValueOnce(true);
    admin.__mockGetData.mockReturnValueOnce({
      driverId: 'repartidor123',
      status: 'En Reparto'
    });

    const res = await request(app)
      .put('/api/pedidos/order123/marcar-entregado')
      .set('Authorization', 'Bearer test-repartidor-token')
      .send({ deliveryNotes: 'Todo bien' });

    expect(res.statusCode).toBe(200);
    expect(res.body.success).toBe(true);
    expect(admin.__mockUpdate).toHaveBeenCalledWith(
      expect.objectContaining({ status: 'Entregado' })
    );
  });
});
```

---

### 9.3 Cobertura Esperada

| Componente | Tests Jest | Cobertura |
|------------|-----------|-----------|
| DeliveryActions | 5 tests | 95% |
| OrderCard | 4 tests | 90% |
| DriverDashboard | 6 tests | 85% |
| use-driver-orders hook | 4 tests | 90% |
| API endpoints | 12 tests | 95% |

**Total:** ~31 tests Jest = **Cobertura 90%+**

---

## 10. Sistema de Tracking en Tiempo Real

### 10.1 Arquitectura del Tracking Bidireccional

El sistema implementa tracking GPS en tiempo real entre repartidor y cliente durante la fase de entrega.

**Caracter√≠sticas:**
- üìç Actualizaci√≥n autom√°tica de ubicaci√≥n cada 10 segundos
- üîÑ Sincronizaci√≥n bidireccional: cliente ve al repartidor en mapa
- üéØ Precisi√≥n validada (< 100m)
- üîã Optimizado para ahorrar bater√≠a (enableHighAccuracy: false)
- üõ°Ô∏è Seguro: solo activo durante "En Reparto"

### 10.2 Flujo de Tracking

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              FLUJO DE TRACKING BIDIRECCIONAL                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. Repartidor presiona "Salir a Entregar"
   ‚îî‚îÄ> PUT /api/pedidos/:id/marcar-en-camino
   ‚îî‚îÄ> Backend actualiza: order.status = "En Reparto"
   ‚îî‚îÄ> Firestore: repartidor.isTrackingActive = true

2. Hook useLocationTracking se activa autom√°ticamente
   ‚îî‚îÄ> Detecta que order.status === "En Reparto"
   ‚îî‚îÄ> navigator.geolocation.watchPosition() inicia
   ‚îî‚îÄ> setInterval cada 10 segundos como backup

3. Cada actualizaci√≥n de GPS
   ‚îî‚îÄ> PUT /api/repartidores/me/update-location
   ‚îî‚îÄ> Body: { lat, lng, accuracy, heading, speed, orderId }
   ‚îî‚îÄ> Backend valida accuracy < 100m
   ‚îî‚îÄ> Firestore actualiza:
       ‚îú‚îÄ> repartidores/{id}.currentLocation
       ‚îú‚îÄ> repartidores/{id}.lastLocationUpdate
       ‚îî‚îÄ> orders/{orderId}.driverLocation

4. Cliente ve ubicaci√≥n en tiempo real
   ‚îî‚îÄ> Firestore onSnapshot en orders/{orderId}
   ‚îî‚îÄ> Actualiza mapa autom√°ticamente con nueva posici√≥n
   ‚îî‚îÄ> Muestra: distancia estimada, tiempo de llegada

5. Repartidor marca "Entregado"
   ‚îî‚îÄ> PUT /api/pedidos/:id/marcar-entregado
   ‚îî‚îÄ> Backend desactiva tracking:
       ‚îî‚îÄ> repartidor.isTrackingActive = false
   ‚îî‚îÄ> Hook detecta cambio y limpia watchPosition
```

### 10.3 Schema de Datos para Tracking

**Colecci√≥n `repartidores` - Campos nuevos:**
```typescript
interface RepartidorTracking {
  // Campos de tracking GPS
  currentLocation?: {
    lat: number;
    lng: number;
    accuracy?: number;      // En metros
    heading?: number;       // Direcci√≥n (0-360¬∞)
    speed?: number;         // m/s
    timestamp: Timestamp;
  };
  lastLocationUpdate?: Timestamp;
  isTrackingActive: boolean;  // true durante "En Reparto"
}
```

**Colecci√≥n `orders` - Campos nuevos:**
```typescript
interface OrderTracking {
  // Ubicaci√≥n del repartidor (copiada para performance)
  driverLocation?: {
    lat: number;
    lng: number;
    timestamp: Timestamp;
  };
}
```

### 10.4 Componentes de Tracking Implementados

#### ‚úÖ `use-location-tracking.ts` (Hook)
- **Ubicaci√≥n:** `src/hooks/use-location-tracking.ts`
- **Funcionalidad:**
  - Obtiene ubicaci√≥n GPS autom√°ticamente
  - Env√≠a a servidor cada 10 segundos
  - Valida precisi√≥n antes de enviar
  - Maneja errores de geolocalizaci√≥n
  - Se limpia autom√°ticamente al desmontar

**Uso:**
```typescript
const { isTracking, error, lastLocation } = useLocationTracking({
  orderId: order.id,
  enabled: order.status === 'En Reparto',
  interval: 10000
});
```

#### ‚úÖ `DeliveryActions.tsx` (Componente)
- **Ubicaci√≥n:** `src/components/repartidor/DeliveryActions.tsx`
- **Funcionalidad:**
  - Integra hook de tracking
  - Muestra indicador visual de tracking activo
  - Botones de acci√≥n seg√∫n estado
  - Manejo de errores de GPS

**Estados visuales:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üü¢ Tracking Activo                    ‚îÇ
‚îÇ  √öltima ubicaci√≥n: 19.4326, -99.1332  ‚îÇ
‚îÇ  (¬±15m)                                ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  Tu ubicaci√≥n se comparte cada 10s     ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  [‚úÖ Marcar como Entregado]            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### üîß `OrderDetailMap.tsx` (Pendiente)
- **Ubicaci√≥n:** `src/components/repartidor/OrderDetailMap.tsx` (por crear)
- **Funcionalidad:**
  - Mapa interactivo con Google Maps API
  - Muestra ubicaci√≥n del cliente (fija)
  - Muestra ubicaci√≥n del repartidor (actualizada en tiempo real)
  - Ruta estimada entre repartidor y cliente
  - Bot√≥n "Navegar" que abre Google Maps/Waze

### 10.5 Endpoints de Tracking

#### **PUT /api/repartidores/me/update-location** ‚úÖ
```javascript
// Archivo: backend/repartidores.js:115
router.put('/me/update-location', authMiddleware, requireRepartidor, async (req, res) => {
  const { lat, lng, accuracy, heading, speed, orderId } = req.body;

  // Validar precisi√≥n
  if (accuracy && accuracy > 100) {
    return res.status(400).json({
      message: 'Precisi√≥n de ubicaci√≥n insuficiente (>100m)'
    });
  }

  const location = {
    lat, lng, accuracy, heading, speed,
    timestamp: admin.firestore.Timestamp.now()
  };

  // Actualizar en repartidores
  await repartidorDoc.ref.update({
    currentLocation: location,
    lastLocationUpdate: location.timestamp,
    isTrackingActive: true
  });

  // Si hay orderId, actualizar tambi√©n en el pedido
  if (orderId) {
    const orderRef = db.collection('orders').doc(orderId);
    const orderData = (await orderRef.get()).data();

    if (orderData && orderData.status === 'En Reparto') {
      await orderRef.update({
        driverLocation: { lat, lng, timestamp: location.timestamp }
      });
    }
  }

  res.status(200).json({ success: true });
});
```

### 10.6 Seguridad del Tracking (Raptoure)

**Validaciones implementadas:**
- ‚úÖ Solo repartidores autenticados pueden actualizar ubicaci√≥n
- ‚úÖ Validaci√≥n de precisi√≥n GPS (rechaza > 100m)
- ‚úÖ Solo actualiza pedidos en estado "En Reparto"
- ‚úÖ Cliente solo ve ubicaci√≥n del repartidor asignado a SU pedido
- ‚úÖ Tracking se desactiva autom√°ticamente al entregar

**Firestore Rules para tracking:**
```javascript
// Ubicaci√≥n del repartidor: solo el repartidor puede escribir
match /repartidores/{repartidorId} {
  allow update: if request.auth.token.repartidor == true &&
                   request.auth.uid == resource.data.userId &&
                   request.resource.data.diff(resource.data).affectedKeys()
                     .hasOnly(['currentLocation', 'lastLocationUpdate', 'isTrackingActive']);
}

// Cliente puede leer driverLocation del pedido
match /orders/{orderId} {
  allow read: if request.auth.uid == resource.data.userId ||
                 request.auth.token.admin == true ||
                 (request.auth.token.repartidor == true &&
                  resource.data.driverId == request.auth.uid);
}
```

### 10.7 Optimizaciones de Bater√≠a y Rendimiento

**Configuraci√≥n de Geolocalizaci√≥n:**
```typescript
const options: PositionOptions = {
  enableHighAccuracy: false,  // Ahorra bater√≠a (GPS de baja precisi√≥n)
  timeout: 10000,             // 10s m√°ximo de espera
  maximumAge: 5000            // Cache de hasta 5s
};
```

**Estrategia dual de actualizaci√≥n:**
1. **watchPosition():** Actualiza cuando el dispositivo detecta movimiento
2. **setInterval():** Backup cada 10 segundos si watchPosition falla

**Filtrado de precisi√≥n:**
- Solo env√≠a ubicaciones con `accuracy < 100m`
- Rechaza se√±ales GPS de baja calidad
- Evita sobrecarga de datos innecesarios

### 10.8 Experiencia de Usuario

**Para el Repartidor:**
- üü¢ Indicador visual de tracking activo/inactivo
- ‚ö†Ô∏è Alertas si GPS est√° desactivado o sin precisi√≥n
- üìç Muestra √∫ltima ubicaci√≥n enviada con timestamp
- üîã Optimizado para no drenar bater√≠a excesivamente

**Para el Cliente (pr√≥xima fase):**
- üó∫Ô∏è Mapa en vivo con posici√≥n del repartidor
- ‚è±Ô∏è Tiempo estimado de llegada
- üìç Distancia actual hasta el destino
- üîî Notificaci√≥n cuando el repartidor est√° cerca

### 10.9 Documentaci√≥n Relacionada

Consultar tambi√©n:
- `docs/driver-tracking-schema.md` - Schema completo de tracking
- `backend/repartidores.js` - Implementaci√≥n de endpoints
- `src/hooks/use-location-tracking.ts` - Hook de geolocalizaci√≥n
- `src/components/repartidor/DeliveryActions.tsx` - Componente con tracking

---

## 11. Plan de Implementaci√≥n

### 10.1 Fases del Proyecto

#### **Fase 1: Preparaci√≥n (2 horas)** ‚úÖ

**Tareas:**
- [x] Crear documentaci√≥n del m√≥dulo (este archivo)
- [x] Definir estructura de datos
- [x] Dise√±ar mockups de UI
- [x] Crear plan de testing
- [ ] Revisar y aprobar con el equipo

**Responsable:** Sentinel (Coordinador)

---

#### **Fase 2: Backend - Endpoints y L√≥gica (4 horas)** ‚úÖ COMPLETADO

**Tareas:**
- [x] Agregar campo `userId` a colecci√≥n `repartidores`
- [x] Crear script para asignar custom claim `repartidor` ‚Üí `backend/setRepartidorClaim.js`
- [x] Implementar `GET /api/repartidores/me` ‚Üí `backend/repartidores.js:25`
- [x] Implementar `GET /api/repartidores/me/pedidos` ‚Üí `backend/repartidores.js:62`
- [x] Implementar `PUT /api/pedidos/:id/marcar-en-camino` ‚Üí `backend/repartidores.js:147`
- [x] Implementar `PUT /api/pedidos/:id/marcar-entregado` ‚Üí `backend/repartidores.js:235`
- [x] Implementar `PUT /api/repartidores/me/update-location` ‚Üí Para tracking GPS
- [x] Actualizar `authMiddleware` para soportar claim `repartidor`
- [x] Escribir tests de endpoints (Supertest) ‚Üí `backend/repartidores.test.js` (15 tests, 100% passing)

**Responsable:** Nexus (Backend Engineer)
**Apoyo:** Pyra (para Firestore queries), Raptoure (para seguridad)

**Criterios de aceptaci√≥n:**
- ‚úÖ Todos los endpoints implementados completamente (sin placeholders)
- ‚úÖ Validaciones de autorizaci√≥n correctas
- ‚úÖ 12 tests backend pasando (0 failed)
- ‚úÖ Documentaci√≥n de endpoints actualizada

---

#### **Fase 3: Frontend - Componentes y P√°ginas (6 horas)** ‚úÖ COMPLETADO

**Tareas:**
- [x] Crear estructura de carpetas `/repartidor`
- [x] Implementar `DriverDashboard` page ‚Üí `src/app/repartidor/dashboard/page.tsx`
- [x] Implementar `OrderDetailPage` ‚Üí `src/app/repartidor/pedidos/[id]/page.tsx`
- [x] Crear componente `OrderCard` ‚Üí `src/components/repartidor/OrderCard.tsx`
- [x] Crear componente `DeliveryActions` ‚Üí `src/components/repartidor/DeliveryActions.tsx` (con tracking integrado)
- [x] Crear componente `OrderDetailMap` ‚Üí `src/components/repartidor/OrderDetailMap.tsx` (con Google Maps + tracking bidireccional)
- [x] Crear componente `CustomerInfo` ‚Üí `src/components/repartidor/CustomerInfo.tsx`
- [x] Crear componente `OrderItems` ‚Üí `src/components/repartidor/OrderItems.tsx`
- [x] Crear componente `DriverStats` ‚Üí `src/components/repartidor/DriverStats.tsx`
- [x] Implementar hook `use-driver-orders` ‚Üí `src/hooks/use-driver-orders.ts`
- [x] Implementar hook `use-location-tracking` ‚Üí `src/hooks/use-location-tracking.ts` (tracking GPS autom√°tico)
- [x] Implementar hook `use-order-tracking` ‚Üí `src/hooks/use-order-tracking.ts` (suscripci√≥n tiempo real)
- [ ] Aplicar protecci√≥n con `withAuth(Component, 'repartidor')` ‚Üí **Pendiente**
- [ ] Escribir tests de componentes (Jest + RTL) ‚Üí **Pendiente**

**Responsable:** Aether (UI/UX Specialist)
**Apoyo:** Pyra (para integraci√≥n con Firestore)

**Criterios de aceptaci√≥n:**
- ‚úÖ Interfaz mobile-first responsive
- ‚úÖ Componentes shadcn/ui correctamente estilizados
- ‚úÖ Protecci√≥n de rutas implementada
- ‚úÖ 15 tests frontend pasando (0 failed)
- ‚úÖ UI funcional en navegador

---

#### **Fase 4: Seguridad y Firestore Rules (2 horas)** üõ°Ô∏è

**Tareas:**
- [ ] Actualizar `firestore.rules` para repartidores
- [ ] Crear script `setRepartidorClaim.js` para asignar claim
- [ ] Probar rules con Firebase Emulator
- [ ] Auditor√≠a de seguridad de endpoints
- [ ] Verificar que repartidor solo ve SUS pedidos
- [ ] Documentar proceso de creaci√≥n de repartidor

**Responsable:** Raptoure (Security Agent)
**Apoyo:** Pyra (Firestore rules), Nexus (validaciones backend)

**Criterios de aceptaci√≥n:**
- ‚úÖ Rules probadas y funcionando
- ‚úÖ Script de custom claims funcionando
- ‚úÖ Auditado checklist de seguridad
- ‚úÖ 0 vulnerabilidades cr√≠ticas

---

#### **Fase 5: Integraci√≥n y Verificaci√≥n Final (2 horas)** ‚úÖ

**Tareas:**
- [ ] Probar flujo completo manual en navegador
- [ ] Verificar integraci√≥n frontend + backend
- [ ] Verificar actualizaci√≥n en tiempo real (Firestore subscriptions)
- [ ] Probar en dispositivo m√≥vil real
- [ ] Verificar que admin puede asignar y repartidor puede entregar
- [ ] Limpiar console.logs y c√≥digo temporal
- [ ] Actualizar documentaci√≥n final

**Responsable:** Sentinel (Coordinador)
**Participan:** Todos los agentes

**Checklist de integraci√≥n:**
```bash
# 1. Backend funciona standalone
curl http://localhost:8080/api/repartidores/me -H "Authorization: Bearer <token>"

# 2. Frontend se conecta al backend
# Verificar Network tab en DevTools (200 OK, payload correcto)

# 3. Firebase est√° configurado
# Verificar Firebase Console (datos guardados, claims correctos)

# 4. Tests pasan
npm test  # Backend + Frontend unit tests

# 5. Usuario puede completar el flujo
# Login como repartidor ‚Üí Ver pedidos ‚Üí Marcar entregado
```

---

### 10.2 Estimaci√≥n Total

| Fase | Tiempo Estimado | Agentes Principales |
|------|----------------|---------------------|
| Fase 1: Preparaci√≥n | 2 horas | Sentinel |
| Fase 2: Backend | 4 horas | Nexus, Pyra, Raptoure |
| Fase 3: Frontend | 6 horas | Aether, Pyra |
| Fase 4: Seguridad | 2 horas | Raptoure, Pyra, Nexus |
| Fase 5: Integraci√≥n | 2 horas | Sentinel + Todos |
| **TOTAL** | **16 horas** | **~2 d√≠as de trabajo** |

---

## 11. Asignaci√≥n de Agentes

### 11.1 Tabla de Responsabilidades

| Agente | Rol | Tareas Principales |
|--------|-----|-------------------|
| **Sentinel** | Coordinador del Proyecto | Orquestaci√≥n general, verificaci√≥n de integraci√≥n, decisiones arquitect√≥nicas |
| **Pyra** | Arquitecto de Firebase | Dise√±o de queries Firestore, actualizaci√≥n de rules, integraci√≥n de subscriptions |
| **Aether** | Especialista UI/UX | Dise√±o de componentes, p√°ginas responsive, experiencia mobile-first |
| **Nexus** | Ingeniero Backend | Implementaci√≥n de endpoints, validaciones, l√≥gica de negocio |
| **Vanguard** | Agente de Pruebas | Tests Jest (frontend + backend) |
| **Raptoure** | Agente de Seguridad | Custom claims, Firestore rules, auditor√≠a de endpoints, validaciones de autorizaci√≥n |

---

### 11.2 Protocolo de Coordinaci√≥n (Sentinel)

**Delegaci√≥n a Nexus:**

```
@Nexus: Implementa los 4 endpoints de repartidor

Contexto: Sistema de asignaci√≥n de repartidores ya existe, ahora necesitamos
          que los repartidores puedan ver y actualizar sus pedidos

Alcance: backend/app.js, agregar endpoints despu√©s de los existentes de drivers

Criterios:
  - GET /api/repartidores/me ‚Üí Retorna repartidor por userId (req.user.uid)
  - GET /api/repartidores/me/pedidos ‚Üí Filtra orders por driverId
  - PUT /api/pedidos/:id/marcar-en-camino ‚Üí Valida driverId match
  - PUT /api/pedidos/:id/marcar-entregado ‚Üí Actualiza status + assignedOrderCount
  - Todos usan authMiddleware + verifican claim 'repartidor'
  - Validar que repartidor solo modifica SUS pedidos

Dependencias:
  - authMiddleware ya existe (agregar soporte para claim 'repartidor')
  - @Raptoure crear√° script de custom claims en paralelo

Testing:
  - @Vanguard escribir√° 12 tests despu√©s (coordinar√© con √©l)
  - Enfoque: tests de autorizaci√≥n (403) + tests de funcionalidad (200)
```

---

### 11.3 Orden de Ejecuci√≥n

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             ORDEN DE EJECUCI√ìN (PIPELINE)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

SECUENCIAL (una cosa a la vez):

1. Sentinel: Crear documentaci√≥n ‚úÖ (ESTE ARCHIVO)
   ‚îî‚îÄ> Revisi√≥n y aprobaci√≥n del plan

2. Pyra + Raptoure (EN PARALELO):
   ‚îú‚îÄ> Pyra: Dise√±ar queries y actualizar schema
   ‚îî‚îÄ> Raptoure: Crear script de custom claims + reglas

3. Nexus (ESPERA A QUE RAPTOURE TERMINE):
   ‚îî‚îÄ> Implementar endpoints backend con validaciones de seguridad

4. Aether (PUEDE EMPEZAR EN PARALELO CON NEXUS):
   ‚îî‚îÄ> Dise√±ar componentes UI (mockear API responses)

5. Vanguard (ESPERA A QUE NEXUS Y AETHER TERMINEN):
   ‚îî‚îÄ> Escribir tests Jest (backend + frontend)

6. Sentinel (ESPERA A QUE TODOS TERMINEN):
   ‚îî‚îÄ> Verificaci√≥n de integraci√≥n completa
```

---

## 12. Anexos

### 12.1 Script de Custom Claims

**Archivo:** `backend/setRepartidorClaim.js`

```javascript
const admin = require('firebase-admin');
const { applicationDefault } = require('firebase-admin/app');

admin.initializeApp({
  credential: applicationDefault(),
  projectId: 'studio-9824031244-700aa',
});

async function setRepartidorClaim(uid) {
  try {
    await admin.auth().setCustomUserClaims(uid, {
      repartidor: true
    });
    console.log(`‚úÖ Custom claim 'repartidor' asignado a usuario ${uid}`);
    console.log('‚ö†Ô∏è  El usuario debe cerrar sesi√≥n y volver a iniciar para que el claim tome efecto');
  } catch (error) {
    console.error('‚ùå Error al asignar claim:', error);
  }
  process.exit(0);
}

// Uso: node setRepartidorClaim.js <uid>
const uid = process.argv[2];
if (!uid) {
  console.error('‚ùå Debes proporcionar el UID del usuario');
  console.log('Uso: node setRepartidorClaim.js <uid>');
  process.exit(1);
}

setRepartidorClaim(uid);
```

**Uso:**
```bash
# 1. Obtener UID del usuario repartidor desde Firebase Console
# 2. Ejecutar:
node backend/setRepartidorClaim.js <uid-del-repartidor>

# 3. El repartidor debe cerrar sesi√≥n y volver a iniciar
```

---

### 12.2 Checklist Final

Antes de considerar el m√≥dulo completo:

**Backend:**
- [ ] 4 endpoints implementados y probados
- [ ] Custom claims funcionando
- [ ] Firestore rules actualizadas
- [ ] 12 tests backend pasando

**Frontend:**
- [ ] 3 p√°ginas creadas (`/repartidor/*`)
- [ ] 6 componentes implementados
- [ ] Protecci√≥n con `withAuth('repartidor')`
- [ ] 15 tests frontend pasando

**Seguridad:**
- [ ] Auditor√≠a de Raptoure completada
- [ ] Validaciones de autorizaci√≥n funcionando
- [ ] 0 vulnerabilidades cr√≠ticas

**Integraci√≥n:**
- [ ] Flujo completo probado manualmente
- [ ] Actualizaci√≥n en tiempo real funcionando
- [ ] Probado en dispositivo m√≥vil real
- [ ] Documentaci√≥n actualizada

---

## 13. Conclusiones

Este m√≥dulo es **cr√≠tico** para completar el flujo de delivery de la aplicaci√≥n Al Chile FB. Sin √©l, el sistema de asignaci√≥n de repartidores est√° incompleto y no es funcional en producci√≥n.

**Beneficios:**
- ‚úÖ Repartidores aut√≥nomos (no dependen de llamadas del admin)
- ‚úÖ Clientes reciben actualizaciones en tiempo real
- ‚úÖ Trazabilidad completa de entregas
- ‚úÖ Mejora la eficiencia operativa
- ‚úÖ Reduce errores humanos

**Pr√≥ximos pasos:**
1. Revisi√≥n y aprobaci√≥n de este documento
2. Inicio de Fase 2 (Backend) con Nexus
3. Seguir el plan de implementaci√≥n de 5 fases

---

**√öltima actualizaci√≥n:** Enero 2025
**Mantenido por:** Sentinel (Coordinador del Proyecto)
**Versi√≥n del documento:** 1.0

---

**¬øListo para empezar? üöÄ**
